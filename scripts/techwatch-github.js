#!/usr/bin/env node

/**
 * SPIRAL TechWatch GitHub Integration
 * Posts KPI summaries and implementation tickets to GitHub Issues
 */

import fs from 'fs';
import path from 'path';
import fetch from 'node-fetch';

class TechWatchGitHub {
  constructor() {
    this.kpiDir = path.join(process.cwd(), 'agents', 'techwatch', 'kpi');
    this.reportsDir = path.join(process.cwd(), 'agents', 'techwatch', 'reports');
    this.githubToken = process.env.GITHUB_TOKEN;
    this.repoOwner = process.env.GITHUB_REPO_OWNER || 'spiral-platform';
    this.repoName = process.env.GITHUB_REPO_NAME || 'spiral-commerce';
    
    if (!this.githubToken) {
      console.log('‚ö†Ô∏è GITHUB_TOKEN not found - will generate local summaries only');
    }
  }

  async postKPISummaries() {
    console.log('üìä SPIRAL TechWatch GitHub Integration Starting...');
    
    try {
      const latestKPI = this.getLatestKPI();
      if (!latestKPI) {
        console.log('‚ùå No KPI reports found');
        return;
      }

      // Generate GitHub-formatted summaries
      const summaries = this.generateSummaries(latestKPI);
      
      // Save local summaries
      await this.saveLocalSummaries(summaries);
      
      // Post to GitHub if token available
      if (this.githubToken) {
        await this.postToGitHub(summaries);
      } else {
        console.log('üìù Local summaries generated (GitHub token not available)');
      }
      
      console.log('‚úÖ TechWatch GitHub integration complete');
      
    } catch (error) {
      console.error('‚ùå GitHub integration failed:', error);
      throw error;
    }
  }

  getLatestKPI() {
    if (!fs.existsSync(this.kpiDir)) return null;
    
    const kpiFiles = fs.readdirSync(this.kpiDir)
      .filter(f => f.startsWith('kpi-') && f.endsWith('.json'))
      .sort()
      .reverse();
    
    if (kpiFiles.length === 0) return null;
    
    const latestFile = path.join(this.kpiDir, kpiFiles[0]);
    return JSON.parse(fs.readFileSync(latestFile, 'utf8'));
  }

  generateSummaries(kpiData) {
    const date = new Date(kpiData.generated).toLocaleDateString();
    
    return {
      executiveSummary: this.generateExecutiveSummary(kpiData, date),
      implementationTickets: this.generateImplementationTickets(kpiData),
      roadmapSummary: this.generateRoadmapSummary(kpiData, date)
    };
  }

  generateExecutiveSummary(kpi, date) {
    return `# üìä SPIRAL TechWatch Executive Summary - ${date}

## üéØ Key Metrics
- **Total Items Analyzed**: ${kpi.totalItems}
- **Ready for Implementation**: ${kpi.initiateCount}
- **Under Watch**: ${kpi.watchCount}
- **Projected Revenue Impact**: $${kpi.projectedRevenueImpact.toLocaleString()}
- **Implementation Timeline**: ${kpi.totalEffortWeeks} weeks
- **ROI Score**: ${kpi.roiScore}/10
- **Risk Assessment**: ${kpi.riskScore}/10

## üìà Strategic Alignment
- **Alignment Score**: ${kpi.strategicAlignment.alignmentScore}/10
- **Strategic Items**: ${kpi.strategicAlignment.alignedCount}/${kpi.strategicAlignment.totalCount}

## üèÜ Top Priority Implementations
${kpi.topPriorities.map((item, idx) => 
  `${idx + 1}. **${item.title}**\n   - Priority Score: ${item.priorityScore}\n   - Effort: ${item.scores?.effort_low_med_high}\n   - Source: ${item.source}`
).join('\n\n')}

## üí∞ Business Impact Analysis
The projected revenue impact of $${kpi.projectedRevenueImpact.toLocaleString()} represents potential annual benefits from implementing these technologies. This includes:

- Enhanced payment processing capabilities
- Improved retail operations efficiency  
- Mobile commerce optimization
- Logistics and fulfillment improvements

## ‚ö†Ô∏è Risk Assessment
Overall risk score of ${kpi.riskScore}/10 indicates ${kpi.riskScore <= 4 ? 'LOW' : kpi.riskScore <= 6 ? 'MODERATE' : 'HIGH'} implementation risk across the portfolio.

## üóìÔ∏è Implementation Roadmap
Total implementation timeline: **${kpi.totalEffortWeeks} weeks**

${Object.entries(kpi.roadmap).map(([quarter, items]) => 
  `### ${quarter}\n${items.map(item => `- ${item.title} (${item.effort} effort)`).join('\n')}`
).join('\n\n')}

---
*Generated by SPIRAL AI R&D Agent - ${new Date(kpi.generated).toLocaleString()}*`;
  }

  generateImplementationTickets(kpi) {
    return kpi.topPriorities.map((item, idx) => ({
      title: `[R&D] Implement ${item.title}`,
      body: `# Implementation Ticket: ${item.title}

## üìã Overview
**Source**: ${item.source}
**Topic**: ${item.topic}
**Decision**: ${item.decision}
**Priority Score**: ${item.priorityScore}

## üìä Scoring Analysis
- **Relevance**: ${item.scores?.relevance_0_5}/5
- **Immediate Impact**: ${item.scores?.impact_now_0_5}/5  
- **12-Month Impact**: ${item.scores?.impact_12mo_0_5}/5
- **Implementation Effort**: ${item.scores?.effort_low_med_high}
- **Legal Risk**: ${item.scores?.legal_risk_low_med_high}

## üìù Summary
${item.summary}

## üéØ Key Benefits
${item.key_points?.map(point => `- ${point}`).join('\n') || '- Analysis in progress'}

## üí° Recommendations
${item.recommendations?.map(rec => `- ${rec}`).join('\n') || '- Detailed recommendations pending'}

## üöÄ Next Actions
${item.next_actions?.map(action => `- **${action.title}** (${action.owner_role}, ${action.eta_days} days)`).join('\n') || '- Action plan to be defined'}

## üîó Reference
- **URL**: ${item.url}
- **Rationale**: ${item.rationale}

---
*Auto-generated by SPIRAL AI R&D Agent*`,
      labels: ['R&D', 'implementation', item.scores?.effort_low_med_high + '-effort', item.topic]
    }));
  }

  generateRoadmapSummary(kpi, date) {
    return `# üó∫Ô∏è SPIRAL TechWatch Implementation Roadmap - ${date}

## üìÖ Quarterly Implementation Plan

${Object.entries(kpi.roadmap).map(([quarter, items]) => `
### ${quarter}
${items.map((item, idx) => 
  `${idx + 1}. **${item.title}**
   - Effort Level: ${item.effort}
   - Priority: ${item.priority}`
).join('\n')}
`).join('\n')}

## üìä Capacity Planning
- **Total Implementation Effort**: ${kpi.totalEffortWeeks} weeks
- **Average per Quarter**: ${Math.round(kpi.totalEffortWeeks / 4)} weeks
- **Peak Quarter**: ${this.getPeakQuarter(kpi.roadmap)}

## üéØ Success Metrics
- **Revenue Target**: $${kpi.projectedRevenueImpact.toLocaleString()}
- **ROI Expected**: ${kpi.roiScore}/10
- **Strategic Alignment**: ${kpi.strategicAlignment.alignmentScore}/10

---
*SPIRAL AI R&D Agent Roadmap Analysis*`;
  }

  getPeakQuarter(roadmap) {
    const efforts = { 'low': 2, 'med': 6, 'high': 12 };
    
    const quarterEfforts = Object.entries(roadmap).map(([quarter, items]) => ({
      quarter,
      totalEffort: items.reduce((sum, item) => sum + (efforts[item.effort] || 6), 0)
    }));
    
    if (quarterEfforts.length === 0) {
      return 'No quarters planned';
    }
    
    const peak = quarterEfforts.reduce((max, current) => 
      current.totalEffort > max.totalEffort ? current : max
    );
    
    return `${peak.quarter} (${peak.totalEffort} weeks)`;
  }

  async saveLocalSummaries(summaries) {
    const summariesDir = path.join(this.kpiDir, 'summaries');
    if (!fs.existsSync(summariesDir)) {
      fs.mkdirSync(summariesDir, { recursive: true });
    }
    
    const timestamp = new Date().toISOString().split('T')[0];
    
    // Save executive summary
    fs.writeFileSync(
      path.join(summariesDir, `executive-summary-${timestamp}.md`),
      summaries.executiveSummary
    );
    
    // Save roadmap
    fs.writeFileSync(
      path.join(summariesDir, `roadmap-${timestamp}.md`),
      summaries.roadmapSummary
    );
    
    // Save implementation tickets as JSON
    fs.writeFileSync(
      path.join(summariesDir, `tickets-${timestamp}.json`),
      JSON.stringify(summaries.implementationTickets, null, 2)
    );
    
    console.log(`üìÅ Local summaries saved to: ${summariesDir}`);
  }

  async postToGitHub(summaries) {
    try {
      // Create executive summary issue
      await this.createGitHubIssue({
        title: `üìä TechWatch Executive Summary - ${new Date().toLocaleDateString()}`,
        body: summaries.executiveSummary,
        labels: ['techwatch', 'executive-summary', 'r&d']
      });
      
      // Create roadmap issue  
      await this.createGitHubIssue({
        title: `üó∫Ô∏è TechWatch Implementation Roadmap - ${new Date().toLocaleDateString()}`,
        body: summaries.roadmapSummary,
        labels: ['techwatch', 'roadmap', 'planning']
      });
      
      // Create implementation tickets
      for (const ticket of summaries.implementationTickets) {
        await this.createGitHubIssue(ticket);
        await this.delay(1000); // Rate limiting
      }
      
      console.log('‚úÖ Posted summaries to GitHub Issues');
      
    } catch (error) {
      console.error('‚ùå Failed to post to GitHub:', error);
    }
  }

  async createGitHubIssue({ title, body, labels = [] }) {
    const url = `https://api.github.com/repos/${this.repoOwner}/${this.repoName}/issues`;
    
    const response = await fetch(url, {
      method: 'POST',
      headers: {
        'Authorization': `token ${this.githubToken}`,
        'Accept': 'application/vnd.github.v3+json',
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        title,
        body,
        labels
      })
    });
    
    if (!response.ok) {
      throw new Error(`GitHub API error: ${response.status} ${response.statusText}`);
    }
    
    const issue = await response.json();
    console.log(`üìù Created issue: ${issue.title} (#${issue.number})`);
    return issue;
  }

  delay(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
}

// CLI execution
if (import.meta.url === `file://${process.argv[1]}`) {
  const github = new TechWatchGitHub();
  github.postKPISummaries()
    .then(() => {
      console.log('‚úÖ TechWatch GitHub integration complete');
      process.exit(0);
    })
    .catch(error => {
      console.error('‚ùå GitHub integration failed:', error);
      process.exit(1);
    });
}

export default TechWatchGitHub;