#!/usr/bin/env bash
set -euo pipefail

# ─────────────────────────────────────────────────────────────
# SPIRAL Feature #6 — Returns UI + Rate Limits + Quote Cache + Availability polish
# - /returns (customer self-service returns)
# - Rate limit: /api/inventory/availability, /api/fulfillment/quote, /api/orders/route
# - Cache: fulfillment quote responses (TTL=30s)
# - Availability adds retailer_zip; add redirect from /cross-retailer-customer to /cross-retailer
# - Roadmap update
# ─────────────────────────────────────────────────────────────

mkdir -p server public/returns data

# Ensure package.json exists
if [ ! -f package.json ]; then
  cat > package.json << 'EOF'
{
  "name": "spiralshops",
  "version": "1.5.0",
  "type": "module",
  "private": true,
  "engines": { "node": ">=18" },
  "scripts": { "start": "node server/index.js" },
  "dependencies": { "express": "^4.19.2" }
}
EOF
else
  sed -i 's/"version": *"[^"]*"/"version": "1.5.0"/' package.json || true
fi

# ─────────────────────────────────────────────────────────────
# Simple in-memory TTL cache
# ─────────────────────────────────────────────────────────────
cat > server/cache.js << 'EOF'
const store = new Map(); // key -> { v, exp }
export function getCache(key){
  const hit = store.get(key);
  if (!hit) return null;
  if (hit.exp < Date.now()){ store.delete(key); return null; }
  return hit.v;
}
export function setCache(key, value, ttlSeconds=30){
  store.set(key, { v: value, exp: Date.now() + ttlSeconds*1000 });
}
EOF

# ─────────────────────────────────────────────────────────────
# Tiny IP rate limiter (fixed window)
# ─────────────────────────────────────────────────────────────
cat > server/rate_limit.js << 'EOF'
const buckets = new Map(); // bucketKey -> { count, reset }
export function createRateLimit(maxPerWindow=60, windowMs=60000){
  return function rateLimit(req, res, next){
    const ip = req.headers['x-forwarded-for']?.split(',')[0]?.trim() || req.socket.remoteAddress || 'unknown';
    const bucketKey = `${req.baseUrl || req.path}:${ip}`;
    const now = Date.now();
    const b = buckets.get(bucketKey);
    if (!b || b.reset <= now){
      buckets.set(bucketKey, { count:1, reset: now + windowMs });
      res.setHeader('X-RateLimit-Limit', String(maxPerWindow));
      res.setHeader('X-RateLimit-Remaining', String(maxPerWindow-1));
      return next();
    }
    if (b.count >= maxPerWindow){
      const retry = Math.max(0, Math.ceil((b.reset - now)/1000));
      res.setHeader('Retry-After', String(retry));
      return res.status(429).json({ error: 'rate_limited', retry_after_seconds: retry });
    }
    b.count++;
    res.setHeader('X-RateLimit-Limit', String(maxPerWindow));
    res.setHeader('X-RateLimit-Remaining', String(Math.max(0, maxPerWindow - b.count)));
    next();
  }
}
EOF

# ─────────────────────────────────────────────────────────────
# Patch: add retailer_zip to availability results in server/inventory.js
# (safe no-op if already present)
# ─────────────────────────────────────────────────────────────
if [ -f server/inventory.js ]; then
  # Add retailer_zip to the returned object if missing
  grep -q "retailer_zip" server/inventory.js || \
  sed -i 's/distance_km/distance_km,\n        retailer_zip: r?.zip/' server/inventory.js
fi

# ─────────────────────────────────────────────────────────────
# Patch: add caching to fulfillment quote route
# ─────────────────────────────────────────────────────────────
if [ -f server/fulfillment.js ]; then
  grep -q "from \"\\.\\/cache\\.js\"" server/fulfillment.js || \
  sed -i '1i import { getCache, setCache } from "./cache.js";' server/fulfillment.js

  # Inject cache lookup before building quotes
  sed -i 's/const from_zip = String(req.query.from_zip||"");/const from_zip = String(req.query.from_zip||"");\n    const cacheKey = `quote:${from_zip}:${String(req.query.to_zip||"")}:${String(req.query.weight_kg||0.5)}`;\n    const cached = getCache(cacheKey);\n    if (cached) { return res.json(cached); }/' server/fulfillment.js

  # After building quotes, set cache and return cached payload
  sed -i 's/res.json({ from_zip, to_zip, km, kg, quotes });/const payload = { from_zip, to_zip, km, kg, quotes };\n    setCache(cacheKey, payload, 30);\n    res.json(payload);/' server/fulfillment.js
fi

# ─────────────────────────────────────────────────────────────
# Wire rate limits and routes in server/index.js
# - Serve /returns page
# - Redirect /cross-retailer-customer -> /cross-retailer
# - Apply rate limits before route handlers
# ─────────────────────────────────────────────────────────────
if [ -f server/index.js ]; then
  grep -q "createRateLimit" server/index.js || \
  sed -i '1i import { createRateLimit } from "./rate_limit.js";' server/index.js

  # Add publicDir var if not present (most setups have it)
  grep -q "publicDir" server/index.js || \
  sed -i 's#const app = express();#const app = express();\n\nconst publicDir = path.join(__dirname, "..", "public");#' server/index.js

  # Mount rate limits BEFORE any route attachments that handle these paths
  grep -q "X-RateLimit-Limit" server/index.js || \
  sed -i 's#attachHardening(app);#attachHardening(app);\n\n// Rate limits\nconst rl60 = createRateLimit(60, 60*1000);\nconst rl30 = createRateLimit(30, 60*1000);\napp.use("/api/inventory/availability", rl60);\napp.use("/api/fulfillment/quote", rl60);\napp.use("/api/orders/route", rl30);\n#' server/index.js

  # Serve /returns page
  grep -q "/returns" server/index.js || \
  sed -i 's#app.use(express.static(publicDir, { index: false }));#app.use(express.static(publicDir, { index: false }));\n\napp.get("/returns", (_req,res)=>{ res.sendFile(path.join(publicDir, "returns", "index.html")); });#' server/index.js

  # Redirect /cross-retailer-customer -> /cross-retailer
  grep -q "/cross-retailer-customer" server/index.js || \
  sed -i 's#app.use(express.static(publicDir, { index: false }));#app.use(express.static(publicDir, { index: false }));\n\napp.get("/cross-retailer-customer", (_req,res)=>{ res.redirect(302, "/cross-retailer"); });#' server/index.js
fi

# ─────────────────────────────────────────────────────────────
# Customer Returns page (self-service)
# ─────────────────────────────────────────────────────────────
cat > public/returns/index.html << 'EOF'
<!doctype html>
<html lang="en">
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>SPIRAL — Returns</title>
<meta name="robots" content="noindex, nofollow">
<style>
:root{--ink:#0b1220;--muted:#6b7280;--br:14px;--btn:#111827}
*{box-sizing:border-box}body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial;color:var(--ink)}
.wrap{max-width:720px;margin:0 auto;padding:22px}
.card{border:1px solid #e5e7eb;border-radius:var(--br);padding:16px;margin:10px 0}
.row{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
input,select,button{padding:10px;border:1px solid #d1d5db;border-radius:12px}
button.btn{background:var(--btn);color:#fff;border:none;cursor:pointer}
.small{color:var(--muted);font-size:.92rem}
pre{background:#f9fafb;border:1px solid #e5e7eb;border-radius:12px;padding:12px;overflow:auto}
a{color:inherit;text-decoration:underline}
</style>

<div class="wrap">
  <header class="row" style="justify-content:space-between">
    <h1>Return an Order</h1>
    <a href="/">Home</a>
  </header>

  <div class="card">
    <div class="row">
      <input id="orderId" placeholder="Order ID">
      <input id="retailerId" placeholder="Retailer ID (if known)">
      <input id="zip" placeholder="Your ZIP">
      <select id="method"><option>dropoff</option><option>pickup</option></select>
      <button class="btn" onclick="createReturn()">Create Return</button>
    </div>
    <div class="small">You will receive a return ID and downloadable label (PDF). For dropoff, you can use any SPIRAL Pickup Center in your area.</div>
  </div>

  <div class="card">
    <h3>Result</h3>
    <pre id="out">—</pre>
    <div id="labelLink"></div>
  </div>

  <div class="card">
    <h3>Your Past Returns</h3>
    <button onclick="listReturns()">Refresh</button>
    <pre id="list">—</pre>
  </div>

  <footer class="small">© SPIRAL — Tech that builds towns • <a href="/admin/fulfillment">Admin Fulfillment</a></footer>
</div>

<script>
async function createReturn(){
  const payload = {
    order_id: document.getElementById('orderId').value.trim(),
    retailer_id: document.getElementById('retailerId').value.trim() || undefined,
    customer_zip: document.getElementById('zip').value.trim() || undefined,
    method: document.getElementById('method').value
  };
  const r = await fetch('/api/fulfillment/returns/create', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify(payload) });
  const data = await r.json();
  document.getElementById('out').textContent = JSON.stringify(data,null,2);
  const link = document.getElementById('labelLink');
  link.innerHTML = data.label_url ? `<a href="${data.label_url}" target="_blank">Download Label (PDF)</a>` : '';
}

async function listReturns(){
  const r = await fetch('/api/fulfillment/returns');
  const data = await r.json();
  document.getElementById('list').textContent = JSON.stringify(data,null,2);
}
</script>
EOF

# ─────────────────────────────────────────────────────────────
# Roadmap update (add/mark tasks)
# ─────────────────────────────────────────────────────────────
if [ ! -f data/roadmap.json ]; then
  cat > data/roadmap.json << 'EOF'
{
  "phase":"Phase 1 — Competitive Gap Closing",
  "items":[
    { "id":"cross_inventory","title":"Cross-Retailer Inventory Referencing (API + UI)","status":"done" },
    { "id":"analytics_hub","title":"Retailer Analytics & Intelligence Hub (MVP)","status":"done" },
    { "id":"local_fulfillment","title":"Local Fulfillment Layer (couriers + returns + pickup)","status":"done" },
    { "id":"event_wiring","title":"Inventory + Fulfillment → Analytics Event Wiring","status":"done" },
    { "id":"returns_ui","title":"Customer Returns Page (/returns)","status":"done" },
    { "id":"rate_limit_cache","title":"Rate Limits + Quote Cache","status":"done" },
    { "id":"postgres_migration","title":"Migrate JSON stores to Postgres","status":"todo" }
  ],
  "last_updated":""
}
EOF
else
  # Best-effort: insert/mark items; keep existing content
  python3 - <<'PY' || true
import json,sys
p="data/roadmap.json"
try:
  with open(p) as f: r=json.load(f)
except: sys.exit(0)
def up(id,title,status):
  it=next((x for x in r.get("items",[]) if x.get("id")==id),None)
  if it: it.update({"title":title,"status":status})
  else: r.setdefault("items",[]).append({"id":id,"title":title,"status":status})
up("returns_ui","Customer Returns Page (/returns)","done")
up("rate_limit_cache","Rate Limits + Quote Cache","done")
up("postgres_migration","Migrate JSON stores to Postgres","todo")
r["last_updated"]=__import__("datetime").datetime.utcnow().isoformat()+"Z"
with open(p,"w") as f: json.dump(r,f,indent=2)
PY
fi

echo "✅ Installed: Returns UI, Rate Limits, Quote Cache, Availability polish, Redirect.
Next:
  npm start

Test quickly:
  • Returns page:          /returns  → create a return and download label
  • Availability (limited):/api/inventory/availability?sku=SKU-HEADPHONES-01&lat=44.98&lng=-93.27&radius_km=30
  • Quotes (limited + cached): /api/fulfillment/quote?from_zip=55101&to_zip=55104&weight_kg=1.2
  • Routing (limited):     POST /api/orders/route
  • Redirect:              /cross-retailer-customer → /cross-retailer

Roadmap now includes:
  - returns_ui (done)
  - rate_limit_cache (done)
  - postgres_migration (todo)
"