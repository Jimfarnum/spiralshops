# =====================================================================
# SPIRAL — Competitive Funnel Intelligence Suite (every 14 days)
# Integrates with TechWatch (reports, tickets, KPI loop)
# =====================================================================

# =========================
# FILE: package.json  (MERGE KEYS — keep your existing ones)
# =========================
{
  "scripts": {
    "techwatch:funnels": "node agents/funnels/run.js",
    "techwatch:funnels:analyze": "node agents/funnels/analyze.js",
    "techwatch:cycle": "node agents/techwatch/scheduler.js"
  },
  "dependencies": {
    "puppeteer": "^22.10.0"
  }
}

# =========================
# FILE: agents/funnels/targets.yml
# =========================
# mode:
#   observe = public pages only (no auth, no form submit)
#   simulate = interact up to but NOT including payment (no real purchase)
competitors:
  - name: Amazon
    domain: amazon.com
    mode: observe
    notes: "Heavily policed anti-bot. Stick to public flows; capture cart gating."
  - name: Target
    domain: target.com
    mode: observe
    notes: "Observe cart/checkout gating; record pickup options."
  - name: Walmart
    domain: walmart.com
    mode: observe
    notes: "Observe express checkout prompts; record memberships/benefits."
  - name: Shopify
    domain: shopify.com
    mode: observe
    notes: "Use generic storefront patterns (Shopify demo stores vary)."

# =========================
# FILE: agents/funnels/utils.js
# =========================
import fs from "fs";
import path from "path";

export function ensureDirs(...dirs){ dirs.forEach(d=>fs.mkdirSync(d,{recursive:true})); }
export function ts(){ return new Date().toISOString(); }
export function safeWriteJSON(p, obj){ fs.writeFileSync(p, JSON.stringify(obj,null,2)); }
export function slug(s){ return String(s||"").toLowerCase().replace(/[^a-z0-9]+/g,"-").replace(/(^-|-$)/g,"").slice(0,60); }
export async function wait(ms){ return new Promise(r=>setTimeout(r,ms)); }
export function loadYAML(file){
  const txt = fs.readFileSync(file,"utf8");
  // ultra-light yaml (we already use real YAML elsewhere, but keep this isolated)
  const YAML = (await import("yaml")).default;
  return YAML.parse(txt);
}

# =========================
# FILE: agents/funnels/capture.js
# =========================
import fs from "fs";
import path from "path";
import puppeteer from "puppeteer";
import { ensureDirs, ts, safeWriteJSON, slug, wait } from "./utils.js";

export async function captureFunnel({ domain, mode, outDir }) {
  ensureDirs(outDir, path.join(outDir,"shots"));
  const browser = await puppeteer.launch({
    headless: process.env.FUNNEL_HEADLESS !== "false",
    args: ["--no-sandbox","--disable-setuid-sandbox","--disable-dev-shm-usage"]
  });
  const page = await browser.newPage();
  await page.setViewport({ width: 1366, height: 900 });

  const records = [];
  async function record(stage, note){
    const fn = `${stage}_${Date.now()}.png`;
    const fp = path.join(outDir,"shots", fn);
    await page.screenshot({ path: fp, fullPage: true });
    const url = page.url();
    const title = await page.title().catch(()=> "");
    records.push({ ts: ts(), stage, note, url, title, shot: `shots/${fn}` });
  }

  // Helpers
  async function gotoSafe(url){
    try { await page.goto(url, { waitUntil: "domcontentloaded", timeout: 45000 }); }
    catch { /* ignore */ }
    await wait(1200);
  }

  // Basic exploration (homepage → search → product → cart → checkout)
  const base = `https://${domain}`;
  await gotoSafe(base);
  await record("home", "Landed on homepage");

  // Search for a simple term that exists on all: "gift card"
  // (low-risk product page that exposes standard PDP/checkout flows)
  try {
    // generic search selectors (fall back heuristics)
    const searchSel = ['input[type="search"]','input[name="q"]','input[name="search"]','input[id*="search"]'];
    let found = false;
    for (const sel of searchSel) {
      const el = await page.$(sel);
      if (el) { await el.click({ clickCount: 3 }).catch(()=>{});
        await page.type(sel, "gift card", { delay: 20 });
        await page.keyboard.press("Enter"); found = true; break; }
    }
    if (found) {
      await page.waitForTimeout(2000);
      await record("search", "Search results page (heuristic)");
    }
  } catch { /* ignore */ }

  // Click first product-like link
  try {
    const firstLink = await page.$('a[href*="/gp/"], a[href*="/p/"], a[href*="/ip/"], a[href*="/products/"], a[href*="/product/"]');
    if (firstLink) {
      await firstLink.click(); await page.waitForTimeout(2000);
      await record("pdp", "Product detail page (heuristic)");
    }
  } catch {}

  // Add to cart (if button present)
  try {
    const addSel = ['button[name="add"], button[id*="add"], button[aria-label*="Add to cart"], button:has-text("Add to cart")'];
    for (const sel of addSel) {
      const btn = await page.$(sel);
      if (btn) { await btn.click(); await page.waitForTimeout(1500); await record("add_to_cart","Clicked Add to cart"); break; }
    }
  } catch {}

  // View cart / mini-cart
  try {
    const cartSel = ['a[href*="cart"]','button[aria-label*="cart"]','a:has-text("Cart")'];
    for (const sel of cartSel) {
      const el = await page.$(sel);
      if (el) { await el.click(); await page.waitForTimeout(2000); await record("cart","Cart or mini-cart"); break; }
    }
  } catch {}

  // Try proceed to checkout (stop before payment)
  try {
    const checkoutSel = ['a[href*="checkout"]','button[name*="checkout"]','button:has-text("Checkout")'];
    for (const sel of checkoutSel) {
      const el = await page.$(sel);
      if (el) { await el.click(); await page.waitForTimeout(2500); await record("checkout_pre_auth","Reached pre-auth checkout"); break; }
    }
  } catch {}

  // Capture common persuasion elements (popups, banners)
  const persuasion = await page.evaluate(()=>{
    const textOf = (el)=> (el?.innerText||"").trim();
    const q = (s)=> Array.from(document.querySelectorAll(s));
    const banners = q('[role="alert"], .banner, .promo, .announcement').map(e=>textOf(e)).filter(Boolean);
    const popups  = q('[role="dialog"], .modal, .popup').map(e=>textOf(e)).filter(Boolean);
    const ctas    = q('button, a').map(e=>textOf(e)).filter(t=>t && t.length<70 && /add|buy|start|join|try|get|learn|shop|subscribe/i.test(t));
    return { banners, popups, ctas: Array.from(new Set(ctas)).slice(0,25) };
  }).catch(()=>({banners:[],popups:[],ctas:[]}));

  await record("end","End of capture session (non-invasive)");
  const out = { domain, mode, started_at: records[0]?.ts, finished_at: ts(), records, persuasion };
  safeWriteJSON(path.join(outDir, `capture_${slug(domain)}.json`), out);

  await browser.close();
  return out;
}

# =========================
# FILE: agents/funnels/analyze.js
# =========================
import fs from "fs";
import path from "path";
import { slug, ensureDirs, safeWriteJSON } from "./utils.js";

const ROOT = path.join(process.cwd(), "agents");
const OUT_BASE = path.join(ROOT, "techwatch","reports");
const FUNNEL_OUT = path.join(ROOT, "funnels","out"); // from run.js

function llmUnavailable(){
  return !process.env.OPENAI_API_KEY || (process.env.OPENAI_API_KEY||"").trim()==="";
}
async function callLLM(prompt){
  const res = await fetch("https://api.openai.com/v1/chat/completions", {
    method:"POST",
    headers:{ "content-type":"application/json", authorization:`Bearer ${process.env.OPENAI_API_KEY}` },
    body: JSON.stringify({
      model: process.env.OPENAI_MODEL || "gpt-4o-mini",
      temperature: 0.2,
      messages: [
        { role:"system", content:"You are a cross-functional growth strategist for SPIRAL. Be pragmatic, structured, and implementation-focused." },
        { role:"user", content: prompt }
      ]
    })
  });
  const json = await res.json();
  const txt = json?.choices?.[0]?.message?.content || "{}";
  try { return JSON.parse(txt); } catch { return { error: "parse_error", raw: txt }; }
}

function buildPrompt({ domain, capture }){
  const capExcerpt = JSON.stringify(capture).slice(0, 12000);
  return `
Return STRICT JSON with keys:
{
 "competitor": "...",
 "domain": "...",
 "funnel_map": { "stages": [ {"name":"...","evidence":["..."]} ] },
 "copy_decoder": { "tone":"...", "headline_hooks":["..."], "cta_patterns":["..."], "framing_devices":["..."], "why_it_converts":"..." },
 "offer_xray": { "pricing":"...", "bonuses":["..."], "urgency_triggers":["..."], "guarantees":["..."], "payment_options":["..."], "positioning":"..." },
 "traffic_sources": { "likely":["paid search","seo","influencers","retargeting"], "audiences":["..."], "targeting_ideas":["..."] },
 "email_blueprint": { "timing":"...", "value_to_pitch_ratio":"...", "subject_line_style":["..."], "storytelling":"...", "cta_patterns":["..."] },
 "leak_finder": { "weak_points":["..."], "fixes_for_spiral":["..."] },
 "differentiation_map": { "overlap":["..."], "unique_angles_for_spiral":["..."], "usps":["..."] },
 "recommendations": [ {"title":"...","owner_role":"Marketing|Product|UX|Engineering","eta_days":14,"impact":"high|med|low"} ],
 "decision": "INITIATE|WATCH|DISCARD",
 "rationale": "why this matters for SPIRAL conversion & onboarding"
}
TEXT (CAPTURE SNIPPET):
${capExcerpt}

META:
competitor="${domain}" mission="Analyze → Create → Implement"
Guide: prefer concrete, testable ideas for SPIRAL onboarding & funnel.
`;
}

export async function analyzeOne({ domain }) {
  const capFile = path.join(FUNNEL_OUT, slug(domain), `capture_${slug(domain)}.json`);
  if (!fs.existsSync(capFile)) throw new Error(`Missing capture for ${domain}`);
  const capture = JSON.parse(fs.readFileSync(capFile,"utf8"));

  if (llmUnavailable()){
    // Conservative heuristic output
    const report = {
      competitor: domain, domain,
      funnel_map: { stages: capture.records.map(r=>({ name: r.stage, evidence:[r.title, r.url].filter(Boolean) })) },
      copy_decoder: { tone:"informational", headline_hooks:[], cta_patterns:capture.persuasion.ctas||[], framing_devices:[], why_it_converts:"Heuristic" },
      offer_xray: { pricing:"Mixed", bonuses:[], urgency_triggers:capture.persuasion.banners||[], guarantees:[], payment_options:[], positioning:"General retailer" },
      traffic_sources: { likely:["seo","retargeting"], audiences:["broad retail"], targeting_ideas:["Local pickup focus"] },
      email_blueprint: { timing:"unknown", value_to_pitch_ratio:"n/a", subject_line_style:[], storytelling:"n/a", cta_patterns:[] },
      leak_finder: { weak_points:["complexity at checkout"], fixes_for_spiral:["1-click wallets; simplified pickup flow"] },
      differentiation_map: { overlap:["assortment"], unique_angles_for_spiral:["local mall pickup","unified multi-merchant cart"], usps:["fast local pickup","mall perks"] },
      recommendations: [{ title:"Enable 1-click wallets with pickup default", owner_role:"Engineering", eta_days:10, impact:"high" }],
      decision: "INITIATE",
      rationale: "Likely conversion uplift via friction reduction."
    };
    return report;
  }

  const prompt = buildPrompt({ domain, capture });
  return await callLLM(prompt);
}

export async function writeIntoTechWatch(report){
  const dateISO = new Date().toISOString().split("T")[0];
  const outDir = path.join(OUT_BASE, dateISO, "funnels");
  ensureDirs(outDir);
  const fp = path.join(outDir, `funnel_${slug(report.domain)}.json`);
  safeWriteJSON(fp, report);

  // Also append to main report.json if exists
  const main = path.join(OUT_BASE, dateISO, "report.json");
  if (fs.existsSync(main)) {
    try {
      const arr = JSON.parse(fs.readFileSync(main,"utf8"));
      arr.push({
        title: `Funnel Insights: ${report.domain}`,
        url: `funnel://${report.domain}`,
        source: "Competitive Funnels",
        topic: "funnel-intel",
        summary: report.rationale || "Funnel analysis",
        key_points: report.recommendations?.map(r=>r.title).slice(0,3) || [],
        scores: { relevance_0_5: 5, impact_now_0_5: 4, impact_12mo_0_5: 4, effort_low_med_high: "med", legal_risk_low_med_high: "low" },
        recommendations: report.recommendations || [],
        next_actions: report.recommendations || [],
        decision: report.decision || "WATCH",
        rationale: report.rationale || ""
      });
      fs.writeFileSync(main, JSON.stringify(arr,null,2));
    } catch { /* ignore */ }
  }
}

# =========================
# FILE: agents/funnels/run.js
# =========================
import fs from "fs";
import path from "path";
import { loadYAML, ensureDirs, slug } from "./utils.js";
import { captureFunnel } from "./capture.js";
import { analyzeOne, writeIntoTechWatch } from "./analyze.js";

const ROOT = path.join(process.cwd(), "agents");
const CFG = path.join(ROOT, "funnels", "targets.yml");
const OUT_BASE = path.join(ROOT, "funnels", "out");

async function main(){
  const cfg = await loadYAML(CFG);
  const targets = cfg.competitors || [];
  for (const t of targets) {
    const outDir = path.join(OUT_BASE, slug(t.domain));
    ensureDirs(outDir);
    console.log(`[Funnels] Capturing: ${t.domain} (${t.mode})`);
    const cap = await captureFunnel({ domain: t.domain, mode: t.mode, outDir });
    console.log(`[Funnels] Analyzing: ${t.domain}`);
    const report = await analyzeOne({ domain: t.domain });
    await writeIntoTechWatch(report);
    console.log(`[Funnels] Done: ${t.domain}`);
  }
  console.log("[Funnels] All targets processed.");
}
main().catch(e=>{ console.error(e); process.exit(1); });

# =========================
# FILE: agents/techwatch/scheduler.js
# =========================
import fs from "fs";
import path from "path";

const STATE = path.join(process.cwd(), "agents","techwatch","state.json");
const INTERVAL_DAYS = Number(process.env.FUNNEL_RUN_INTERVAL_DAYS || 14);

function readState(){ try{ return JSON.parse(fs.readFileSync(STATE,"utf8")); } catch { return {}; } }
function writeState(s){ fs.writeFileSync(STATE, JSON.stringify(s,null,2)); }

function daysSince(iso){
  if (!iso) return Number.POSITIVE_INFINITY;
  const then = new Date(iso).getTime();
  const now  = Date.now();
  return (now - then) / (1000*60*60*24);
}

async function run(cmd){
  console.log(`[Scheduler] Running: ${cmd}`);
  const { execa } = await import("execa"); // light proc runner
  try { await execa("bash", ["-lc", cmd], { stdio: "inherit" }); }
  catch (e) { console.error(`[Scheduler] ${cmd} failed`, e?.shortMessage || e?.message); }
}

async function main(){
  const st = readState();
  // Always refresh TechWatch (news/AI/R&D) daily; avoid cron complexity here
  await run("npm run techwatch:scan");

  // 14-day guard for funnels
  const last = st.last_funnel_run_at;
  const delta = daysSince(last);
  if (delta >= INTERVAL_DAYS - 0.25) { // small buffer
    await run("npm run techwatch:funnels");
    st.last_funnel_run_at = new Date().toISOString();
    writeState(st);
  } else {
    console.log(`[Scheduler] Funnels not due. Days since last: ${delta.toFixed(1)}/${INTERVAL_DAYS}`);
  }
}
main().catch(e=>{ console.error(e); process.exit(1); });

# =========================
# FILE: server/adminTechwatchFunnelsRoute.js
# =========================
import express from "express";
import fs from "fs";
import path from "path";
import { guard } from "./adminAuth.js";

const router = express.Router();
router.use(guard);

const BASE = path.join(process.cwd(),"agents","techwatch","reports");

router.get("/techwatch/funnels/latest", (req,res)=>{
  try{
    const days = fs.readdirSync(BASE).filter(d=>/^\d{4}-\d{2}-\d{2}$/.test(d)).sort();
    if (!days.length) return res.json({ ok:true, items:[] });
    const dir = path.join(BASE, days[days.length-1], "funnels");
    if (!fs.existsSync(dir)) return res.json({ ok:true, items:[] });
    const files = fs.readdirSync(dir).filter(f=>f.endsWith(".json"));
    const items = files.map(f=>JSON.parse(fs.readFileSync(path.join(dir,f),"utf8")));
    res.json({ ok:true, items });
  } catch(e){
    console.error(e); res.status(500).json({ ok:false, error:e.message });
  }
});

router.post("/techwatch/funnels/run-now", async (req,res)=>{
  try{
    const { execa } = await import("execa");
    await execa("bash",["-lc","npm run techwatch:funnels"],{stdio:"inherit"});
    res.json({ ok:true });
  } catch(e){
    console.error(e); res.status(500).json({ ok:false, error:e.message });
  }
});

export default router;

# =========================
# FILE: app/AdminTechWatchFunnels.jsx  (optional UI panel)
# =========================
import React, { useEffect, useState } from "react";
export default function AdminTechWatchFunnels(){
  const [items,setItems] = useState([]);
  const [msg,setMsg] = useState("");
  async function load(){
    setMsg("Loading…");
    const r = await fetch("/admin/techwatch/funnels/latest");
    if (r.status===401) { window.location.href="/admin/login"; return; }
    const d = await r.json();
    setItems(d.items||[]); setMsg("");
  }
  useEffect(()=>{ load(); },[]);
  async function runNow(){
    setMsg("Running capture & analysis…");
    const r = await fetch("/admin/techwatch/funnels/run-now",{ method:"POST" });
    const d = await r.json();
    setMsg(d.ok ? "Done." : (d.error||"Error"));
    await load();
  }
  return (
    <div className="p-4 border rounded-2xl">
      <div className="flex items-center justify-between mb-3">
        <h2 className="text-lg font-semibold">Competitive Funnels (14-day cycle)</h2>
        <button onClick={runNow} className="px-3 py-1 rounded-lg bg-black text-white">Run Now</button>
      </div>
      {msg && <div className="text-sm text-gray-700 mb-2">{msg}</div>}
      <div className="grid md:grid-cols-2 gap-4">
        {(items||[]).map((it,idx)=>(
          <div key={idx} className="p-3 rounded-xl border">
            <div className="text-sm text-gray-500 mb-1">{it.domain}</div>
            <div className="font-medium mb-2">{it.differentiation_map?.usps?.join(" • ") || "—"}</div>
            <ul className="list-disc ml-5 text-sm">
              {(it.recommendations||[]).slice(0,3).map((r,i)=><li key={i}>{r.title} <i className="text-gray-500">({r.owner_role}, {r.eta_days}d)</i></li>)}
            </ul>
          </div>
        ))}
      </div>
    </div>
  );
}

# =========================
# FILE: server/index.js  (ADD near your existing mounts)
# =========================
// import adminTechwatchFunnels from "./adminTechwatchFunnelsRoute.js";
// app.use("/admin", adminTechwatchFunnels);

# =====================================================================
# HOW IT WORKS
# =====================================================================
# 1) Every day, run the scheduler (add to Replit cron or call manually):
#    npm run techwatch:cycle
#    - Always refreshes TechWatch news/AI report (existing "techwatch:scan")
#    - Triggers funnel capture+analysis if ≥ FUNNEL_RUN_INTERVAL_DAYS (default 14)
#
# 2) Manual run anytime:
#    npm run techwatch:funnels
#
# 3) Outputs:
#    - Capture:   agents/funnels/out/<domain>/capture_<domain>.json + screenshots
#    - Reports:   agents/techwatch/reports/YYYY-MM-DD/funnels/funnel_<domain>.json
#    - Main TechWatch report.json gets appended with a "Funnel Insights" item
#
# 4) Tickets & KPI:
#    - Your existing "Approve & Initiate" flow will create tickets from report items
#      (funnel insights are appended with decision & recommendations).
#
# =====================================================================
# SECRETS / ENV (Replit → Secrets)
# =====================================================================
# FUNNEL_HEADLESS=true              # run headless browser (default true)
# FUNNEL_RUN_INTERVAL_DAYS=14       # interval guard
# OPENAI_API_KEY=...                # for high-quality analysis
# OPENAI_MODEL=gpt-4o-mini          # optional
#
# (Existing secrets for tickets/KPI remain: GITHUB_TOKEN, GITHUB_REPO, etc.)
#
# =====================================================================
# COMPLIANCE & SAFETY NOTES
# =====================================================================
# - This suite is set to "observe" public flows by default (no auth, no payment).
# - Do not submit real payment or personal data. Stop prior to payment page.
# - Respect site Terms; throttle requests; keep headless=true for low noise.
# - You can opt-up to "simulate" per domain in targets.yml if legal permits.
# =====================================================================