/**
 * scripts/setupSpiralCart.js
 *
 * Replit-friendly one-click installer (NO Bash) for SPIRAL's local-first
 * multi-retailer cart + embedded checkout scaffolding.
 *
 * HOW TO USE (Replit):
 * 1) Create folder "scripts" at your project root (if it doesn't exist).
 * 2) Add this file as scripts/setupSpiralCart.js
 * 3) In the Replit shell, run:  node scripts/setupSpiralCart.js
 * 4) Import and render <SpiralCartDemo /> somewhere in your client app to preview.
 *
 * This script:
 *  - Creates backend APIs: /api/cart and /api/checkout (Express)
 *  - Creates frontend React components: SpiralCart + SpiralCartDemo
 *  - Creates a thin client lib for fetch calls
 *  - Ensures routes are mounted (server/routes.ts or server/routes.js)
 *  - Writes a .env (if missing)
 *  - Installs npm deps (stripe, zod, express, cors, body-parser)
 *
 * Safe to re-run. It won't delete your files; it only writes missing ones
 * and appends route mounts if not present.
 */

const fs = require("fs");
const path = require("path");
const { execSync } = require("child_process");

// ----------------------- Config (edit if needed) -----------------------
const SERVER_DIR = "server";
const CLIENT_DIR = "client";
const API_DIR = path.join(SERVER_DIR, "api");
const ROUTES_TS = path.join(SERVER_DIR, "routes.ts");
const ROUTES_JS = path.join(SERVER_DIR, "routes.js");
const ENV_FILE = ".env";
// ----------------------------------------------------------------------

function ensureDir(p) {
  if (!fs.existsSync(p)) fs.mkdirSync(p, { recursive: true });
}

function writeIfMissing(filePath, contents, label) {
  if (!fs.existsSync(filePath)) {
    fs.mkdirSync(path.dirname(filePath), { recursive: true });
    fs.writeFileSync(filePath, contents, "utf8");
    log(`Created ${label}: ${filePath}`);
  } else {
    log(`Exists (kept): ${filePath}`);
  }
}

function appendIfMissing(filePath, needle, toAppend) {
  if (!fs.existsSync(filePath)) return false;
  const src = fs.readFileSync(filePath, "utf8");
  if (!src.includes(needle)) {
    fs.writeFileSync(filePath, `${src.trim()}\n${toAppend}\n`, "utf8");
    log(`Appended to ${filePath}: ${needle}`);
    return true;
  }
  log(`Already present in ${filePath}: ${needle}`);
  return false;
}

function installDeps(pkgs) {
  try {
    log(`Installing deps: ${pkgs.join(" ")}`);
    execSync(`npm i ${pkgs.join(" ")}`, { stdio: "inherit" });
  } catch (e) {
    warn(`npm install failed. You can run manually: npm i ${pkgs.join(" ")}`);
  }
}

function log(msg) {
  console.log(`\x1b[36m[SPIRAL]\x1b[0m ${msg}`);
}
function warn(msg) {
  console.warn(`\x1b[33m[SPIRAL WARN]\x1b[0m ${msg}`);
}

// ----------------------------- Ensure Dirs -----------------------------
ensureDir(API_DIR);
ensureDir(path.join(CLIENT_DIR, "components"));
ensureDir(path.join(CLIENT_DIR, "lib"));

// ---------------------------- .env (dev) -------------------------------
writeIfMissing(
  ENV_FILE,
  `# --- SPIRAL DEV ENV ---
STRIPE_SECRET_KEY=sk_test_xxx_replace_me
STRIPE_WEBHOOK_SECRET=whsec_xxx_replace_me

# Marketplace settings
SPIRAL_PLATFORM_FEE_BPS=500
SPIRAL_LOYALTY_RATE_BPS=100

# App URLs
APP_BASE_URL=http://localhost:3000
CLIENT_BASE_URL=http://localhost:5173
NODE_ENV=development
`,
  ".env"
);

// --------------------------- API: cart.js ------------------------------
writeIfMissing(
  path.join(API_DIR, "cart.js"),
  `/**
 * SPIRAL Cart API (Local-First, Multi-Retailer)
 * Demo in-memory store. Replace with Cloudant/DB for production.
 */
const { z } = require("zod");

const carts = new Map(); // sessionId -> cart

const LineSchema = z.object({
  sku: z.string(),
  title: z.string(),
  price: z.number().nonnegative(),
  image: z.string().optional(),
  merchantId: z.string(),
  merchantName: z.string(),
  qty: z.number().int().positive().default(1),
  fulfillment: z.enum(["pickup", "delivery"]).default("pickup"),
  distanceMiles: z.number().optional(),
  mallId: z.string().optional(),
  mallName: z.string().optional(),
  spiralsEarn: z.number().int().nonnegative().default(0),
});

const UpsertLinesSchema = z.object({
  sessionId: z.string(),
  lines: z.array(LineSchema),
});

const UpdateQtySchema = z.object({
  sessionId: z.string(),
  sku: z.string(),
  merchantId: z.string(),
  qty: z.number().int().positive(),
});

const UpdateFulfillmentSchema = z.object({
  sessionId: z.string(),
  sku: z.string(),
  merchantId: z.string(),
  fulfillment: z.enum(["pickup", "delivery"]),
});

function ensureCart(sessionId) {
  if (!carts.has(sessionId)) {
    carts.set(sessionId, {
      sessionId,
      merchants: [],
      totals: { subtotal: 0, spirals: 0, merchants: 0 },
      badges: [],
    });
  }
  return carts.get(sessionId);
}

function recompute(cart) {
  let subtotal = 0;
  let spirals = 0;
  cart.merchants.forEach(m => {
    m.lines.forEach(l => {
      subtotal += l.price * l.qty;
      spirals += l.spiralsEarn ?? 0;
    });
  });
  cart.totals = { subtotal, spirals, merchants: cart.merchants.length };
  cart.badges = [];
  const hasMall = cart.merchants.some(m => m.lines.some(l => l.mallId));
  if (hasMall) cart.badges.push("Mall-Stop Ready");
  return cart;
}

function upsertLines(sessionId, lines) {
  const cart = ensureCart(sessionId);
  lines.forEach(line => {
    let m = cart.merchants.find(mm => mm.merchantId === line.merchantId);
    if (!m) {
      m = { merchantId: line.merchantId, merchantName: line.merchantName, lines: [] };
      cart.merchants.push(m);
    }
    const idx = m.lines.findIndex(ll => ll.sku === line.sku);
    if (idx >= 0) m.lines[idx].qty += line.qty;
    else m.lines.push(line);
  });
  return recompute(cart);
}

function updateQty(sessionId, merchantId, sku, qty) {
  const cart = ensureCart(sessionId);
  const m = cart.merchants.find(mm => mm.merchantId === merchantId);
  if (!m) return cart;
  const l = m.lines.find(ll => ll.sku === sku);
  if (!l) return cart;
  l.qty = qty;
  return recompute(cart);
}

function updateFulfillment(sessionId, merchantId, sku, fulfillment) {
  const cart = ensureCart(sessionId);
  const m = cart.merchants.find(mm => mm.merchantId === merchantId);
  if (!m) return cart;
  const l = m.lines.find(ll => ll.sku === sku);
  if (!l) return cart;
  l.fulfillment = fulfillment;
  return recompute(cart);
}

module.exports = (app) => {
  app.post("/api/cart/upsert", (req, res) => {
    try {
      const { sessionId, lines } = UpsertLinesSchema.parse(req.body);
      const cart = upsertLines(sessionId, lines);
      res.json(cart);
    } catch (e) {
      res.status(400).json({ error: e.message });
    }
  });

  app.post("/api/cart/update-qty", (req, res) => {
    try {
      const { sessionId, merchantId, sku, qty } = UpdateQtySchema.parse(req.body);
      const cart = updateQty(sessionId, merchantId, sku, qty);
      res.json(cart);
    } catch (e) {
      res.status(400).json({ error: e.message });
    }
  });

  app.post("/api/cart/update-fulfillment", (req, res) => {
    try {
      const { sessionId, merchantId, sku, fulfillment } = UpdateFulfillmentSchema.parse(req.body);
      const cart = updateFulfillment(sessionId, merchantId, sku, fulfillment);
      res.json(cart);
    } catch (e) {
      res.status(400).json({ error: e.message });
    }
  });

  app.get("/api/cart/:sessionId", (req, res) => {
    const cart = ensureCart(req.params.sessionId);
    res.json(cart);
  });
};
`,
  "server/api/cart.js"
);

// ------------------------- API: checkout.js ----------------------------
writeIfMissing(
  path.join(API_DIR, "checkout.js"),
  `/**
 * SPIRAL LocalPay Checkout (demo)
 * - Creates a placeholder "clientSecret" and returns platform fee calc.
 * - Replace with real Stripe PaymentIntent + Connect transfers for prod.
 */
const Stripe = require("stripe");
const stripe = Stripe(process.env.STRIPE_SECRET_KEY || "", { apiVersion: "2024-06-20" });
const { z } = require("zod");

const CheckoutSchema = z.object({
  sessionId: z.string(),
  email: z.string().email(),
  cart: z.object({
    merchants: z.array(z.object({
      merchantId: z.string(),
      merchantName: z.string(),
      stripeAccountId: z.string().optional(),
      lines: z.array(z.object({
        sku: z.string(),
        title: z.string(),
        price: z.number(),
        qty: z.number().int().positive(),
        fulfillment: z.enum(["pickup", "delivery"]),
      })),
    })),
    totals: z.object({
      subtotal: z.number(),
      spirals: z.number(),
      merchants: z.number(),
    }),
  }),
});

module.exports = (app) => {
  app.post("/api/checkout/create-intent", async (req, res) => {
    try {
      const payload = CheckoutSchema.parse(req.body);
      const platformFeeBps = parseInt(process.env.SPIRAL_PLATFORM_FEE_BPS || "500", 10);
      const platformFee = Math.round(payload.cart.totals.subtotal * (platformFeeBps / 10000));

      // DEMO: simulate a client secret
      const clientSecret = "pi_demo_client_secret_" + Math.random().toString(36).slice(2);

      res.json({
        ok: true,
        clientSecret,
        platformFee,
        amount: Math.round(payload.cart.totals.subtotal * 100),
        currency: "usd",
      });
    } catch (e) {
      console.error(e);
      res.status(400).json({ ok: false, error: e.message });
    }
  });
};
`,
  "server/api/checkout.js"
);

// ------------------------ routes.ts / routes.js -----------------------
const hasRoutesTs = fs.existsSync(ROUTES_TS);
const hasRoutesJs = fs.existsSync(ROUTES_JS);

// If neither exists, create a simple JS bootstrap.
if (!hasRoutesTs && !hasRoutesJs) {
  writeIfMissing(
    ROUTES_JS,
    `// SPIRAL basic Express bootstrap (JS)
const express = require("express");
const cors = require("cors");
const bodyParser = require("body-parser");

const app = express();
app.use(cors());
app.use(bodyParser.json({ limit: "2mb" }));

require("./api/cart")(app);
require("./api/checkout")(app);

app.get("/healthz", (_, res) => res.json({ ok: true }));

module.exports = app;
`,
    "server/routes.js"
  );
}

appendIfMissing(ROUTES_TS, `require("./api/cart")(app);`, `require("./api/cart")(app);`);
appendIfMissing(ROUTES_TS, `require("./api/checkout")(app);`, `require("./api/checkout")(app);`);
appendIfMissing(ROUTES_JS, `require("./api/cart")(app);`, `require("./api/cart")(app);`);
appendIfMissing(ROUTES_JS, `require("./api/checkout")(app);`, `require("./api/checkout")(app);`);

// -------------------------- client/lib API ----------------------------
writeIfMissing(
  path.join(CLIENT_DIR, "lib", "spiralApi.ts"),
  `export type Line = {
  sku: string;
  title: string;
  price: number;
  image?: string;
  merchantId: string;
  merchantName: string;
  qty: number;
  fulfillment: "pickup" | "delivery";
  distanceMiles?: number;
  mallId?: string;
  mallName?: string;
  spiralsEarn?: number;
};

export async function getCart(sessionId: string) {
  const r = await fetch(\`/api/cart/\${encodeURIComponent(sessionId)}\`);
  return r.json();
}

export async function upsertLines(sessionId: string, lines: Line[]) {
  const r = await fetch(\`/api/cart/upsert\`, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ sessionId, lines }),
  });
  return r.json();
}

export async function updateQty(sessionId: string, merchantId: string, sku: string, qty: number) {
  const r = await fetch(\`/api/cart/update-qty\`, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ sessionId, merchantId, sku, qty }),
  });
  return r.json();
}

export async function updateFulfillment(sessionId: string, merchantId: string, sku: string, fulfillment: "pickup"|"delivery") {
  const r = await fetch(\`/api/cart/update-fulfillment\`, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ sessionId, merchantId, sku, fulfillment }),
  });
  return r.json();
}

export async function createCheckoutIntent(sessionId: string, email: string, cart: any) {
  const r = await fetch(\`/api/checkout/create-intent\`, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ sessionId, email, cart }),
  });
  return r.json();
}
`,
  "client/lib/spiralApi.ts"
);

// --------------------- client/components (React) ----------------------
writeIfMissing(
  path.join(CLIENT_DIR, "components", "SpiralCart.tsx"),
  `import React, { useEffect, useMemo, useState } from "react";
import { getCart, updateQty, updateFulfillment, createCheckoutIntent, upsertLines, type Line } from "../lib/spiralApi";

type Merchant = {
  merchantId: string;
  merchantName: string;
  lines: Line[];
};

type Cart = {
  sessionId: string;
  merchants: Merchant[];
  totals: { subtotal: number; spirals: number; merchants: number };
  badges: string[];
};

function dollars(v: number) { return \`$\${v.toFixed(2)}\`; }

export default function SpiralCart({
  sessionId,
  demoSeed,
  emailForCheckout,
  onCheckoutReady,
}: {
  sessionId: string;
  demoSeed?: Line[];
  emailForCheckout?: string;
  onCheckoutReady?: (info: { clientSecret: string }) => void;
}) {
  const [cart, setCart] = useState<Cart | null>(null);
  const [loading, setLoading] = useState(false);
  const [checkingOut, setCheckingOut] = useState(false);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    (async () => {
      if (demoSeed && demoSeed.length) await upsertLines(sessionId, demoSeed);
      const c = await getCart(sessionId);
      setCart(c);
    })();
  }, [sessionId, demoSeed]);

  const subtotal = useMemo(() => (cart?.totals?.subtotal ?? 0), [cart]);

  async function handleQty(merchantId: string, sku: string, qty: number) {
    setLoading(true);
    const c = await updateQty(sessionId, merchantId, sku, Math.max(1, qty));
    setCart(c);
    setLoading(false);
  }

  async function handleFulfillment(merchantId: string, sku: string, fulfillment: "pickup"|"delivery") {
    setLoading(true);
    const c = await updateFulfillment(sessionId, merchantId, sku, fulfillment);
    setCart(c);
    setLoading(false);
  }

  async function handleCheckout() {
    try {
      if (!cart) return;
      setCheckingOut(true);
      const email = emailForCheckout || "shopper@example.com";
      const r = await createCheckoutIntent(sessionId, email, cart);
      if (!r.ok) throw new Error(r.error || "Checkout failed");
      onCheckoutReady?.({ clientSecret: r.clientSecret });
      setCheckingOut(false);
      alert("LocalPay initialized (demo). Client Secret: " + r.clientSecret);
    } catch (e: any) {
      setCheckingOut(false);
      setError(e.message);
    }
  }

  if (!cart) return <div className="p-4">Loading SPIRAL Cart…</div>;

  return (
    <div className="max-w-2xl mx-auto my-6 rounded-2xl shadow-lg border p-4 bg-white">
      <div className="flex items-center justify-between">
        <h1 className="text-2xl font-bold">Your SPIRAL Cart</h1>
        <div className="text-sm text-gray-500">Checkout once for all, earn SPIRALS on every item</div>
      </div>

      <div className="mt-2 flex gap-2">
        {cart.badges?.map((b) => (
          <span key={b} className="inline-flex items-center rounded-full border px-2 py-0.5 text-xs">{b}</span>
        ))}
        {cart.totals?.spirals ? (
          <span className="inline-flex items-center rounded-full bg-blue-50 text-blue-700 px-2 py-0.5 text-xs">
            +{cart.totals.spirals} SPIRALS
          </span>
        ) : null}
      </div>

      <div className="divide-y mt-4">
        {cart.merchants.map((m) => (
          <div key={m.merchantId} className="py-4">
            <div className="font-semibold text-lg">{m.merchantName}</div>
            <div className="text-xs text-gray-500">Mall-Stop Ready when multiple items share a mall</div>
            <div className="mt-3 space-y-3">
              {m.lines.map((l) => (
                <div key={l.sku} className="flex items-center justify-between gap-3">
                  <div className="flex-1">
                    <div className="font-medium">{l.title}</div>
                    <div className="text-sm text-gray-500">
                      {l.fulfillment === "pickup" ? "Picked Up Today" : "Delivery"}{l.distanceMiles ? \` • \${l.distanceMiles} mi\` : ""}
                    </div>
                    <div className="mt-1">
                      <label className="text-xs mr-2">Fulfillment:</label>
                      <select
                        className="border rounded px-2 py-1 text-sm"
                        value={l.fulfillment}
                        onChange={(e) => handleFulfillment(m.merchantId, l.sku, e.target.value as any)}
                        disabled={loading}
                      >
                        <option value="pickup">Pickup</option>
                        <option value="delivery">Delivery</option>
                      </select>
                    </div>
                    {l.spiralsEarn ? (
                      <div className="mt-1">
                        <span className="inline-flex items-center rounded-full bg-blue-50 text-blue-700 px-2 py-0.5 text-xs">
                          Earn {l.spiralsEarn} SPIRALS
                        </span>
                      </div>
                    ) : null}
                  </div>
                  <div className="flex items-center gap-2">
                    <div className="text-right">
                      <div className="font-semibold">{dollars(l.price)}</div>
                      <div className="flex items-center gap-2 mt-1">
                        <button className="border rounded px-2" onClick={() => handleQty(m.merchantId, l.sku, (l.qty - 1))} disabled={loading}>–</button>
                        <div className="w-8 text-center">{l.qty}</div>
                        <button className="border rounded px-2" onClick={() => handleQty(m.merchantId, l.sku, (l.qty + 1))} disabled={loading}>+</button>
                      </div>
                    </div>
                  </div>
                </div>
              ))}
            </div>
          </div>
        ))}
      </div>

      <div className="mt-4 flex items-center justify-between">
        <div className="flex items-center gap-2">
          <span className="inline-flex h-5 w-5 items-center justify-center rounded-full border">✓</span>
          <span className="font-medium">Local Impact</span>
        </div>
        <div className="text-xl font-bold">{dollars(subtotal)}</div>
      </div>

      {error && <div className="mt-2 text-red-600 text-sm">{error}</div>}

      <button
        onClick={handleCheckout}
        disabled={checkingOut}
        className="mt-4 w-full rounded-xl py-3 font-semibold bg-orange-500 text-white hover:bg-orange-600"
      >
        {checkingOut ? "Initializing LocalPay…" : "LocalPay Checkout"}
      </button>
    </div>
  );
}
`,
  "client/components/SpiralCart.tsx"
);

writeIfMissing(
  path.join(CLIENT_DIR, "components", "SpiralCartDemo.tsx"),
  `import React from "react";
import SpiralCart from "./SpiralCart";
import type { Line } from "../lib/spiralApi";

const demoSeed: Line[] = [
  {
    sku: "sweater-patagonia-gray-m",
    title: "Patagonia Better Sweater (Gray • M)",
    price: 139.0,
    image: "",
    merchantId: "downtown-outdoors",
    merchantName: "Downtown Outdoors",
    qty: 1,
    fulfillment: "pickup",
    distanceMiles: 2.5,
    spiralsEarn: 3,
  },
  {
    sku: "book-midnight-library",
    title: "The Midnight Library — Matt Haig",
    price: 18.0,
    merchantId: "greenfield-books",
    merchantName: "Greenfield Books",
    qty: 1,
    fulfillment: "pickup",
    distanceMiles: 1.8,
    mallId: "northwood-mall",
    mallName: "Northwood Mall",
    spiralsEarn: 1,
  },
];

export default function SpiralCartDemo() {
  return (
    <div className="p-4">
      <SpiralCart sessionId="demo-session" demoSeed={demoSeed} />
    </div>
  );
}
`,
  "client/components/SpiralCartDemo.tsx"
);

// --------------------------- Install Deps -----------------------------
installDeps(["stripe", "zod", "express", "cors", "body-parser"]);

// ------------------------------ README -------------------------------
writeIfMissing(
  "SPIRAL_CART_README.txt",
  `SPIRAL Cart + LocalPay (One-Cart, Multi-Retailer) — Quick Start
===============================================================

Added
-----
1) server/api/cart.js
   - /api/cart/:sessionId (GET)
   - /api/cart/upsert (POST)
   - /api/cart/update-qty (POST)
   - /api/cart/update-fulfillment (POST)

2) server/api/checkout.js
   - /api/checkout/create-intent (POST)
   - Demo clientSecret; replace with real Stripe PaymentIntent + Connect transfers.

3) server/routes.(ts|js)
   - Ensures cart + checkout routes are mounted.

4) client/lib/spiralApi.ts
   - Thin fetch client.

5) client/components/SpiralCart.tsx
   - SPIRAL-branded Cart + LocalPay Checkout UI.

6) client/components/SpiralCartDemo.tsx
   - Demo with seeded items.

Try it
------
- Frontend: render <SpiralCartDemo /> somewhere in your app.
- Backend: ensure your Express server uses server/routes.(ts|js).

Next
----
- Swap in-memory cart for Cloudant/DB.
- Add tax/shipping, mall consolidation, returns-at-center flows.
- Wire telemetry to the Concept Validity Dashboard.
`,
  "SPIRAL_CART_README.txt"
);

// ---------------------------- Done -----------------------------------
log("✅ SPIRAL Cart + LocalPay setup complete.");
log("Next: render client/components/SpiralCartDemo.tsx to preview.");
log("Update your STRIPE_SECRET_KEY in .env before production.");
```0